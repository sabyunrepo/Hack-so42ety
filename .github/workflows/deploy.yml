name: ğŸš€ Deploy MoriAI

on:
  push:
    branches:
      - dev      # Dev í™˜ê²½ ë°°í¬
      - main     # Production í™˜ê²½ ë°°í¬

jobs:
  # ==================== Dev í™˜ê²½ ë°°í¬ ====================
  deploy-dev:
    name: ğŸ”§ Deploy to Dev Server
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/dev'
    
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4
      
      - name: ğŸ”‘ Setup SSH Key
        run: |
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          
          # SSH Private Key ì„¤ì •
          echo "${{ secrets.DEV_SSH_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          
          # SSH known_hosts ì„¤ì •
          echo "ğŸ” Scanning host key for 14.36.34.122:23..."
          ssh-keyscan -p 23 -T 10 14.36.34.122 >> ~/.ssh/known_hosts 2>/dev/null || echo "âš ï¸ ssh-keyscan failed, but continuing..."
          
          # SSH config ì„¤ì •
          cat > ~/.ssh/config << 'EOF'
          Host 14.36.34.122
            Port 23
            StrictHostKeyChecking accept-new
            UserKnownHostsFile ~/.ssh/known_hosts
            ConnectTimeout 30
            ServerAliveInterval 60
            ServerAliveCountMax 3
          EOF
          chmod 600 ~/.ssh/config
          
          echo "âœ… SSH setup completed"
      
      - name: ğŸ” Test SSH Connection
        env:
          DEV_HOST: "14.36.34.122"
          DEV_PORT: "23"
          DEV_USER: "${{ secrets.DEV_SSH_USER || 'ubuntu' }}"
        run: |
          echo "ğŸ” Testing SSH connection to ${DEV_USER}@${DEV_HOST}:${DEV_PORT}..."
          ssh -p ${DEV_PORT} ${DEV_USER}@${DEV_HOST} "echo 'âœ… SSH connection successful'" || {
            echo "âŒ SSH connection failed!"
            exit 1
          }
      
      - name: ğŸ“Š Deploy to Dev Server
        env:
          DEV_HOST: "14.36.34.122"
          DEV_PORT: "23"
          DEV_USER: "${{ secrets.DEV_SSH_USER || 'ubuntu' }}"
        run: |
          echo "ğŸš€ Deploying to Dev Server (14.36.34.122:23)..."
          
          ssh -p ${DEV_PORT} ${DEV_USER}@${DEV_HOST} << 'ENDSSH'
            set -e
            
            echo "ğŸ“‚ Navigating to project directory..."
            cd ~/Hack-so42ety || exit 1
            
            echo "ğŸ“¥ Pulling latest code (dev branch)..."
            git fetch origin dev
            git checkout dev
            git pull origin dev
            
            echo "ğŸ”„ Stopping existing containers..."
            # 1. ë¨¼ì € ì»¨í…Œì´ë„ˆ ì¤‘ì§€ (graceful shutdown)
            docker compose -f docker-compose.yml stop || true
            
            # 2. ì»¨í…Œì´ë„ˆ ì œê±° ë° ë„¤íŠ¸ì›Œí¬ ì •ë¦¬
            docker compose -f docker-compose.yml down --remove-orphans || true
            
            # 3. íŠ¹ì • ì»¨í…Œì´ë„ˆ ì´ë¦„ìœ¼ë¡œ ê°•ì œ ì œê±° (í˜¹ì‹œ ëª¨ë¥¼ ê²½ìš°)
            echo "ğŸ” Checking for leftover containers..."
            for container in moriai-redis moriai-postgres moriai-nginx moriai-backend moriai-frontend-builder moriai-cloudflared; do
              if docker ps -a --format '{{.Names}}' | grep -q "^${container}$"; then
                echo "âš ï¸ Removing leftover container: $container"
                docker stop $container 2>/dev/null || true
                docker rm -f $container 2>/dev/null || true
              fi
            done
            
            # 4. í˜¸ìŠ¤íŠ¸ í¬íŠ¸ë¥¼ ì§ì ‘ í™•ì¸í•˜ê³  í•´ì œ (ë” ì •í™•í•œ ë°©ë²•)
            echo "ğŸ” Checking for processes using ports 6379, 5432, 80..."
            for port in 6379 5432 80; do
              pids=""
              
              # lsofê°€ ê°€ì¥ ì •í™•í•¨ (ìš°ì„  ì‚¬ìš©)
              if command -v lsof >/dev/null 2>&1; then
                pids=$(lsof -ti:${port} 2>/dev/null | tr '\n' ' ' || true)
              # ss ëª…ë ¹ì–´ ì‚¬ìš© (í˜¸í™˜ì„± ìˆëŠ” ë°©ë²•)
              elif command -v ss >/dev/null 2>&1; then
                # ss ì¶œë ¥ì—ì„œ PID ì¶”ì¶œ (sed ì‚¬ìš©)
                pids=$(ss -tlnp 2>/dev/null | grep ":${port} " | sed -n 's/.*pid=\([0-9]*\).*/\1/p' | sort -u | tr '\n' ' ' || true)
              # netstat ì‚¬ìš© (êµ¬ë²„ì „ í˜¸í™˜)
              elif command -v netstat >/dev/null 2>&1; then
                pids=$(netstat -tlnp 2>/dev/null | grep ":${port} " | awk '{print $7}' | cut -d'/' -f1 | grep -E '^[0-9]+$' | sort -u | tr '\n' ' ' || true)
              fi
              
              if [ -n "$pids" ]; then
                echo "âš ï¸ Found process(es) using port $port: $pids"
                for pid in $pids; do
                  pid=$(echo $pid | tr -d ' ')  # ê³µë°± ì œê±°
                  if [ -n "$pid" ] && [ "$pid" != "0" ]; then
                    # Docker ì»¨í…Œì´ë„ˆ í”„ë¡œì„¸ìŠ¤ì¸ì§€ í™•ì¸
                    if [ -f "/proc/${pid}/cgroup" ] && grep -q docker "/proc/${pid}/cgroup" 2>/dev/null; then
                      echo "   â†’ Killing Docker container process: $pid"
                      kill -9 $pid 2>/dev/null || true
                    else
                      echo "   â†’ Killing host process: $pid"
                      kill -9 $pid 2>/dev/null || true
                    fi
                  fi
                done
                sleep 2
              fi
              
              # Docker ì»¨í…Œì´ë„ˆê°€ í¬íŠ¸ë¥¼ ì‚¬ìš©í•˜ëŠ”ì§€ ë‹¤ì‹œ í™•ì¸
              container_id=$(docker ps -a --format '{{.ID}}\t{{.Names}}\t{{.Ports}}' 2>/dev/null | grep -E ":${port}|127\.0\.0\.1:${port}" | awk '{print $1}' | head -1 || true)
              if [ -n "$container_id" ]; then
                echo "âš ï¸ Found Docker container using port $port: $container_id"
                docker stop $container_id 2>/dev/null || true
                docker rm -f $container_id 2>/dev/null || true
              fi
            done
            
            # 5. ëª¨ë“  moriai ê´€ë ¨ ì»¨í…Œì´ë„ˆ ê°•ì œ ì œê±°
            echo "ğŸ§¹ Cleaning up all moriai containers..."
            docker ps -a --filter "name=moriai" --format '{{.ID}}' | xargs -r docker rm -f 2>/dev/null || true
            
            # 6. ì»¨í…Œì´ë„ˆì™€ í¬íŠ¸ê°€ ì™„ì „íˆ í•´ì œë  ë•Œê¹Œì§€ ëŒ€ê¸°
            echo "â³ Waiting for containers and ports to fully release (10s)..."
            sleep 10
            
            # 7. ìµœì¢… í¬íŠ¸ í™•ì¸
            echo "ğŸ” Final port check..."
            for port in 6379 5432 80; do
              if command -v ss >/dev/null 2>&1; then
                if ss -tln | grep -q ":${port} "; then
                  echo "âš ï¸ WARNING: Port $port is still in use!"
                  ss -tlnp | grep ":${port} " || true
                else
                  echo "âœ“ Port $port is free"
                fi
              fi
            done
            
            echo "ğŸ—ï¸ Building images..."
            docker compose -f docker-compose.yml build --no-cache
            
            echo "ğŸš€ Starting services..."
            docker compose -f docker-compose.yml up -d
            
            echo "â³ Waiting for services to start (10s)..."
            sleep 10
            
            echo "ğŸ—„ï¸ Running database migrations..."
            docker compose -f docker-compose.yml exec -T backend alembic upgrade head || echo "âš ï¸ Migration failed or no changes"
            
            echo "âœ… Dev deployment completed!"
          ENDSSH
      
      - name: ğŸ¥ Health Check
        run: |
          echo "ğŸ¥ Checking service health..."
          sleep 5
          curl -f http://14.36.34.122/api/health || echo "âš ï¸ Health check failed"
      
      - name: ğŸ“ Deployment Summary
        run: |
          echo "### ğŸ‰ Dev Deployment Complete!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment**: Development" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch**: dev" >> $GITHUB_STEP_SUMMARY
          echo "- **Server**: 14.36.34.122:23" >> $GITHUB_STEP_SUMMARY
          echo "- **URL**: http://14.36.34.122" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit**: ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY

  # ==================== Production í™˜ê²½ ë°°í¬ ====================
  deploy-prod:
    name: ğŸš€ Deploy to Production (AWS EC2)
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4
      
      - name: ğŸ” Check Runner IP
        run: |
          echo "ğŸ” GitHub Actions Runner ì •ë³´:"
          echo "Runner IP: $(curl -s --max-time 5 https://api.ipify.org || echo 'í™•ì¸ ë¶ˆê°€')"
          echo ""
          echo "GitHub Actions IP ë²”ìœ„ (ì¼ë¶€):"
          curl -s --max-time 5 https://api.github.com/meta | jq -r '.actions[]' | head -5 || echo "í™•ì¸ ë¶ˆê°€"
          echo ""
      
      - name: ğŸ”‘ Setup SSH Key
        env:
          PROD_HOST: "${{ secrets.PROD_HOST }}"
        run: |
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          
          # PROD_HOST í™•ì¸
          if [ -z "${{ secrets.PROD_HOST }}" ]; then
            echo "âŒ PROD_HOST is not set!"
            exit 1
          fi
          
          echo "ğŸ“‹ ì„¤ì • ì •ë³´:"
          echo "  PROD_HOST: ${{ secrets.PROD_HOST }}"
          echo "  PROD_USER: ${{ secrets.PROD_SSH_USER || 'ubuntu' }}"
          echo ""
          
          # SSH Private Key ì„¤ì •
          echo "ğŸ”‘ Setting up SSH Private Key..."
          if [ -z "${{ secrets.PROD_SSH_KEY }}" ]; then
            echo "âŒ PROD_SSH_KEY is not set!"
            exit 1
          fi
          
          echo "${{ secrets.PROD_SSH_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          
          # SSH Key ìœ íš¨ì„± í™•ì¸
          if ! head -1 ~/.ssh/id_rsa | grep -q "BEGIN.*PRIVATE KEY"; then
            echo "âŒ SSH Key í˜•ì‹ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤!"
            echo "ì²« ì¤„: $(head -1 ~/.ssh/id_rsa)"
            exit 1
          fi
          
          echo "âœ… SSH Key ì„¤ì • ì™„ë£Œ"
          echo ""
          
          # SSH known_hosts ì„¤ì •
          echo "ğŸ” Scanning host key for ${{ secrets.PROD_HOST }}..."
          ssh-keyscan -T 10 ${{ secrets.PROD_HOST }} >> ~/.ssh/known_hosts 2>/dev/null || {
            echo "âš ï¸ ssh-keyscan failed, but continuing..."
          }
          
          # SSH config ì„¤ì • (ìµœì í™”)
          cat > ~/.ssh/config << EOF
          Host ${{ secrets.PROD_HOST }}
            User ${{ secrets.PROD_SSH_USER || 'ubuntu' }}
            StrictHostKeyChecking accept-new
            UserKnownHostsFile ~/.ssh/known_hosts
            ConnectTimeout 60
            ServerAliveInterval 30
            ServerAliveCountMax 3
            TCPKeepAlive yes
            LogLevel ERROR
          EOF
          chmod 600 ~/.ssh/config
          
          echo "âœ… SSH config ì„¤ì • ì™„ë£Œ"
          echo ""
          echo "ğŸ“‹ SSH config ë‚´ìš©:"
          cat ~/.ssh/config
          echo ""
      
      - name: ğŸ” Test SSH Connection (ìƒì„¸ ë””ë²„ê¹…)
        env:
          PROD_HOST: "${{ secrets.PROD_HOST }}"
          PROD_USER: "${{ secrets.PROD_SSH_USER || 'sabyun' }}"
        run: |
          echo "ğŸ” SSH ì—°ê²° í…ŒìŠ¤íŠ¸ ì‹œì‘..."
          echo ""
          echo "ğŸ“‹ ì—°ê²° ì •ë³´:"
          echo "  Host: ${PROD_HOST}"
          echo "  User: ${PROD_USER}"
          echo "  Port: 22"
          echo ""
          
          # í¬íŠ¸ ì—°ê²° í…ŒìŠ¤íŠ¸
          echo "ğŸ” í¬íŠ¸ 22 ì—°ê²° í…ŒìŠ¤íŠ¸..."
          if command -v nc &> /dev/null; then
            timeout 10 nc -zv ${PROD_HOST} 22 2>&1 || echo "âš ï¸ í¬íŠ¸ ì—°ê²° ì‹¤íŒ¨"
          else
            timeout 10 bash -c "</dev/tcp/${PROD_HOST}/22" 2>&1 || echo "âš ï¸ í¬íŠ¸ ì—°ê²° ì‹¤íŒ¨"
          fi
          echo ""
          
          # SSH ì—°ê²° í…ŒìŠ¤íŠ¸ (ìƒì„¸ ë¡œê·¸)
          echo "ğŸ” SSH ì—°ê²° í…ŒìŠ¤íŠ¸ (ìƒì„¸ ëª¨ë“œ)..."
          SSH_OUTPUT=$(ssh -v -o ConnectTimeout=60 -o StrictHostKeyChecking=no ${PROD_USER}@${PROD_HOST} "echo 'âœ… SSH connection successful'" 2>&1)
          SSH_EXIT_CODE=$?
          
          if [ $SSH_EXIT_CODE -eq 0 ]; then
            echo "âœ… SSH connection successful!"
            echo "$SSH_OUTPUT" | grep -E "(Authenticated|successful)" || echo "$SSH_OUTPUT"
          else
            echo "âŒ SSH connection failed! (exit code: $SSH_EXIT_CODE)"
            echo ""
            echo "ğŸ“‹ ìƒì„¸ ì˜¤ë¥˜ ë¡œê·¸:"
            echo "$SSH_OUTPUT" | tail -20
            echo ""
            
            # ì˜¤ë¥˜ ë¶„ì„
            if echo "$SSH_OUTPUT" | grep -qi "Connection timed out"; then
              echo "ğŸ” ì›ì¸: Connection timed out"
              echo "  â†’ ë„¤íŠ¸ì›Œí¬ ë ˆë²¨ì—ì„œ ì—°ê²° ì°¨ë‹¨"
              echo "  â†’ Security Group ë˜ëŠ” Network ACL í™•ì¸ í•„ìš”"
            elif echo "$SSH_OUTPUT" | grep -qi "Connection refused"; then
              echo "ğŸ” ì›ì¸: Connection refused"
              echo "  â†’ SSH ì„œë¹„ìŠ¤ê°€ ì‹¤í–‰ ì¤‘ì´ì§€ ì•Šê±°ë‚˜ í¬íŠ¸ê°€ ë‹¤ë¦„"
            elif echo "$SSH_OUTPUT" | grep -qi "Permission denied"; then
              echo "ğŸ” ì›ì¸: Permission denied"
              echo "  â†’ SSH Key ì¸ì¦ ì‹¤íŒ¨"
              echo "  â†’ GitHub Secretsì˜ PROD_SSH_KEY í™•ì¸ í•„ìš”"
            fi
            echo ""
            echo "ğŸ”§ í•´ê²° ë°©ë²•:"
            echo "  1. AWS Console â†’ EC2 â†’ Security Groups"
            echo "  2. ì¸ìŠ¤í„´ìŠ¤ì˜ Security Group (sg-0bd8f1b8b2a2bf792) ì„ íƒ"
            echo "  3. Inbound Rules í™•ì¸: SSH (22) 0.0.0.0/0 í—ˆìš©"
            echo "  4. VPC â†’ Network ACLs â†’ SSH (22) í¬íŠ¸ ëª…ì‹œì  í—ˆìš© í™•ì¸"
            echo ""
            exit 1
          fi
      
      - name: ğŸ—„ï¸ Backup Database
        env:
          PROD_HOST: "${{ secrets.PROD_HOST }}"
          PROD_USER: "${{ secrets.PROD_SSH_USER || 'ubuntu' }}"
        run: |
          echo "ğŸ’¾ Creating database backup..."
          ssh ${PROD_USER}@${PROD_HOST} << 'ENDSSH'
            cd ~/Hack-so42ety
            make db-backup-prod || echo "âš ï¸ Backup failed (may not exist yet)"
          ENDSSH
      
      - name: ğŸš€ Deploy to Production
        env:
          PROD_HOST: "${{ secrets.PROD_HOST }}"
          PROD_USER: "${{ secrets.PROD_SSH_USER || 'ubuntu' }}"
        run: |
          echo "ğŸš€ Deploying to Production (AWS EC2)..."
          
          ssh ${PROD_USER}@${PROD_HOST} << 'ENDSSH'
            set -e
            
            echo "ğŸ“‚ Navigating to project directory..."
            cd ~/Hack-so42ety || exit 1
            
            echo "ğŸ“¥ Pulling latest code (main branch)..."
            git fetch origin main
            git checkout main
            git pull origin main
            
            echo "ğŸ”„ Stopping existing containers..."
            # 1. ë¨¼ì € ì»¨í…Œì´ë„ˆ ì¤‘ì§€ (graceful shutdown)
            docker compose -f docker-compose.prod.yml stop || true
            
            # 2. ì»¨í…Œì´ë„ˆ ì œê±° ë° ë„¤íŠ¸ì›Œí¬ ì •ë¦¬
            docker compose -f docker-compose.prod.yml down --remove-orphans || true
            
            # 3. íŠ¹ì • ì»¨í…Œì´ë„ˆ ì´ë¦„ìœ¼ë¡œ ê°•ì œ ì œê±° (í˜¹ì‹œ ëª¨ë¥¼ ê²½ìš°)
            echo "ğŸ” Checking for leftover containers..."
            for container in moriai-redis-prod moriai-postgres-prod moriai-nginx-prod moriai-backend-prod moriai-frontend-builder-prod moriai-cloudflared-prod; do
              if docker ps -a --format '{{.Names}}' | grep -q "^${container}$"; then
                echo "âš ï¸ Removing leftover container: $container"
                docker stop $container 2>/dev/null || true
                docker rm -f $container 2>/dev/null || true
              fi
            done
            
            # 4. í˜¸ìŠ¤íŠ¸ í¬íŠ¸ë¥¼ ì§ì ‘ í™•ì¸í•˜ê³  í•´ì œ (ë” ì •í™•í•œ ë°©ë²•)
            echo "ğŸ” Checking for processes using ports 6379, 5432, 80..."
            for port in 6379 5432 80; do
              # ss ëª…ë ¹ì–´ë¡œ í¬íŠ¸ ì‚¬ìš© í”„ë¡œì„¸ìŠ¤ í™•ì¸
              if command -v ss >/dev/null 2>&1; then
                pids=$(ss -tlnp | grep ":${port} " | grep -oP 'pid=\K[0-9]+' | sort -u || true)
              elif command -v lsof >/dev/null 2>&1; then
                pids=$(lsof -ti:${port} 2>/dev/null || true)
              else
                # netstat ì‚¬ìš© (êµ¬ë²„ì „ í˜¸í™˜)
                pids=$(netstat -tlnp 2>/dev/null | grep ":${port} " | awk '{print $7}' | cut -d'/' -f1 | grep -E '^[0-9]+$' | sort -u || true)
              fi
              
              if [ -n "$pids" ]; then
                echo "âš ï¸ Found process(es) using port $port: $pids"
                for pid in $pids; do
                  # Docker ì»¨í…Œì´ë„ˆ í”„ë¡œì„¸ìŠ¤ì¸ì§€ í™•ì¸
                  if [ -f "/proc/${pid}/cgroup" ] && grep -q docker "/proc/${pid}/cgroup" 2>/dev/null; then
                    echo "   â†’ Killing Docker container process: $pid"
                    kill -9 $pid 2>/dev/null || true
                  else
                    echo "   â†’ Killing host process: $pid"
                    kill -9 $pid 2>/dev/null || true
                  fi
                done
                sleep 1
              fi
              
              # Docker ì»¨í…Œì´ë„ˆê°€ í¬íŠ¸ë¥¼ ì‚¬ìš©í•˜ëŠ”ì§€ ë‹¤ì‹œ í™•ì¸
              container_id=$(docker ps -a --format '{{.ID}}\t{{.Names}}\t{{.Ports}}' | grep -E ":(${port}|127\.0\.0\.1:${port})" | awk '{print $1}' | head -1 || true)
              if [ -n "$container_id" ]; then
                echo "âš ï¸ Found Docker container using port $port: $container_id"
                docker stop $container_id 2>/dev/null || true
                docker rm -f $container_id 2>/dev/null || true
              fi
            done
            
            # 5. ëª¨ë“  moriai ê´€ë ¨ ì»¨í…Œì´ë„ˆ ê°•ì œ ì œê±°
            echo "ğŸ§¹ Cleaning up all moriai containers..."
            docker ps -a --filter "name=moriai" --format '{{.ID}}' | xargs -r docker rm -f 2>/dev/null || true
            
            # 6. ì»¨í…Œì´ë„ˆì™€ í¬íŠ¸ê°€ ì™„ì „íˆ í•´ì œë  ë•Œê¹Œì§€ ëŒ€ê¸°
            echo "â³ Waiting for containers and ports to fully release (10s)..."
            sleep 10
            
            # 7. ìµœì¢… í¬íŠ¸ í™•ì¸
            echo "ğŸ” Final port check..."
            for port in 6379 5432 80; do
              if command -v ss >/dev/null 2>&1; then
                if ss -tln | grep -q ":${port} "; then
                  echo "âš ï¸ WARNING: Port $port is still in use!"
                  ss -tlnp | grep ":${port} " || true
                else
                  echo "âœ“ Port $port is free"
                fi
              fi
            done
            
            echo "ğŸ—ï¸ Building production images..."
            DOCKER_BUILDKIT=1 docker compose -f docker-compose.prod.yml build --progress=plain
            
            echo "ğŸš€ Starting production services..."
            docker compose -f docker-compose.prod.yml --profile production up -d
            
            echo "â³ Waiting for services to start (15s)..."
            sleep 15
            
            echo "ğŸ—„ï¸ Running database migrations..."
            docker compose -f docker-compose.prod.yml exec -T backend alembic upgrade head || echo "âš ï¸ Migration failed or no changes"
            
            echo "ğŸ§¹ Cleaning up old images..."
            docker image prune -f || true
            
            echo "âœ… Production deployment completed!"
          ENDSSH
      
      - name: ğŸ¥ Health Check
        env:
          PROD_HOST: "${{ secrets.PROD_HOST }}"
        run: |
          echo "ğŸ¥ Checking production service health..."
          sleep 5
          curl -f --max-time 10 http://${PROD_HOST}/api/health || echo "âš ï¸ Health check failed"
      
      - name: ğŸ“Š Check Service Status
        env:
          PROD_HOST: "${{ secrets.PROD_HOST }}"
          PROD_USER: "${{ secrets.PROD_SSH_USER || 'ubuntu' }}"
        run: |
          echo "ğŸ“Š Checking service status..."
          ssh ${PROD_USER}@${PROD_HOST} << 'ENDSSH'
            cd ~/Hack-so42ety
            docker compose -f docker-compose.prod.yml ps
          ENDSSH
      
      - name: ğŸ“ Deployment Summary
        env:
          PROD_HOST: "${{ secrets.PROD_HOST }}"
        run: |
          echo "### ğŸ‰ Production Deployment Complete!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment**: Production" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch**: main" >> $GITHUB_STEP_SUMMARY
          echo "- **Server**: AWS EC2 (${PROD_HOST})" >> $GITHUB_STEP_SUMMARY
          echo "- **URL**: http://${PROD_HOST}" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit**: ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "âœ… All services are running!" >> $GITHUB_STEP_SUMMARY
